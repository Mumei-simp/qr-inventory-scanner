<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Pro Scanner</title>
    <script src="https://unpkg.com/html5-qrcode"></script>
    <style>
        :root { --primary: #2563eb; --bg: #0f172a; --error: #dc2626; }
        body { font-family: system-ui, sans-serif; background: var(--bg); color: white; padding: 10px; display: flex; flex-direction: column; align-items: center; margin: 0; }
        #reader video { filter: contrast(1.6) brightness(1.1) grayscale(0.4); object-fit: cover !important; }
        #reader-wrapper { position: relative; width: 100%; max-width: 500px; border-radius: 12px; overflow: hidden; border: 2px solid #334155; background: #000; }
        .laser { position: absolute; top: 40%; left: 5%; width: 90%; height: 2px; background: #22c55e; box-shadow: 0 0 12px #22c55e; z-index: 10; pointer-events: none; animation: scanning 2s infinite ease-in-out; }
        @keyframes scanning { 0%, 100% { transform: translateY(-40px); } 50% { transform: translateY(40px); } }
        .card { background: #1e293b; width: 100%; max-width: 500px; padding: 15px; border-radius: 12px; margin-top: 10px; box-sizing: border-box; border: 1px solid #334155; }
        .status-pill { display: block; text-align: center; padding: 12px; border-radius: 8px; font-size: 0.85rem; font-weight: 800; margin-bottom: 12px; text-transform: uppercase; }
        .syncing { background: #334155; color: #94a3b8; }
        .ready { background: #16a34a; color: white; }
        .is-dup { background: var(--error); color: white; }
        .zoom-row { margin-bottom: 15px; background: #0f172a; padding: 10px; border-radius: 8px; border: 1px solid #334155; }
        .zoom-header { display: flex; justify-content: space-between; font-size: 0.75rem; color: #94a3b8; margin-bottom: 8px; font-weight: bold; }
        input[type="range"] { width: 100%; height: 10px; border-radius: 5px; background: #334155; accent-color: #3b82f6; cursor: pointer; }
        input[type="text"] { width: 100%; padding: 14px; background: #0f172a; border: 1px solid #334155; border-radius: 8px; color: white; font-size: 16px; margin: 10px 0; }
        button { width: 100%; padding: 16px; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 700; cursor: pointer; }
        .bottom-btns { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
    </style>
</head>
<body>

    <div id="reader-wrapper">
        <div id="reader"></div>
        <div class="laser"></div>
    </div>

    <div class="card">
        <div id="status" class="status-pill syncing">FETCHING DATABASE...</div>
        
        <div id="zoom-container" class="zoom-row" style="display:none;">
            <div class="zoom-header">
                <span>ZOOM MAGNIFICATION</span>
                <span id="zoom-value">1.0x</span>
            </div>
            <input type="range" id="zoom-dial" min="1" max="5" step="0.1" value="1">
        </div>

        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
            <input type="checkbox" id="cont-scan">
            <label for="cont-scan" style="font-size: 0.9rem; font-weight: 500;">Auto-Push to Sheet</label>
        </div>

        <div id="manual-form" style="display: none; border-top: 1px solid #475569; padding-top: 15px;">
            <div id="display-serial" style="font-size: 1.3rem; font-weight: 800; color: #60a5fa; margin-bottom: 5px;">---</div>
            <input type="text" id="item-name" placeholder="Item Name (Optional)">
            <button onclick="manualPush()">PUSH DATA</button>
        </div>
        
        <div class="bottom-btns">
            <button id="torch-btn" style="display:none; background: #475569;" onclick="toggleTorch()">ðŸ”¦ LIGHT</button>
            <button style="background: #475569;" onclick="refreshAll()">ðŸ”„ REFRESH</button>
        </div>
    </div>

    <script>
        const scriptURL = "https://script.google.com/macros/s/AKfycbzNSy4eQ5Tm3ZR429ozDAp7MekYHzQu5qEmLAFgYpqtUaxHGAIjMcEG5a4R9vqrrhKn/exec";
        const cache = new Set();
        let isLock = false;
        let html5QrCode;
        let isTorchOn = false;

        const statusEl = document.getElementById('status');
        const contSwitch = document.getElementById('cont-scan');
        const manualForm = document.getElementById('manual-form');
        const serialTxt = document.getElementById('display-serial');
        const nameInput = document.getElementById('item-name');
        const torchBtn = document.getElementById('torch-btn');
        const zoomDial = document.getElementById('zoom-dial');
        const zoomValue = document.getElementById('zoom-value');
        const zoomContainer = document.getElementById('zoom-container');

        // Helper to get the active video track reliably
        async function getActiveVideoTrack(retries = 6, delayMs = 300) {
            // Try library method first if available
            try {
                if (html5QrCode && typeof html5QrCode.getRunningTrack === 'function') {
                    const t = html5QrCode.getRunningTrack();
                    if (t) return t;
                }
            } catch (e) {
                console.log('getRunningTrack not available or threw', e);
            }

            for (let i = 0; i < retries; i++) {
                try {
                    const video = document.querySelector('#reader video');
                    if (video && video.srcObject) {
                        const tracks = video.srcObject.getVideoTracks();
                        if (tracks && tracks.length) return tracks[0];
                    }
                } catch (e) {
                    console.log('video track read attempt failed', e);
                }
                await new Promise(r => setTimeout(r, delayMs));
            }
            return null;
        }

        async function init() {
            html5QrCode = new Html5Qrcode("reader");
            
            // 1. Fetch Duplicates
            try {
                const res = await fetch(`${scriptURL}?action=fetch`);
                const data = await res.json();
                if (data.serials) data.serials.forEach(s => cache.add(String(s).trim()));
                statusEl.innerText = `${cache.size} ITEMS LOADED`;
                statusEl.className = "status-pill ready";
            } catch (e) {
                console.warn('Fetch failed, offline mode', e);
                statusEl.innerText = "OFFLINE MODE";
                statusEl.className = "status-pill syncing";
            }

            // 2. Start Camera
            const config = { 
                fps: 30, 
                qrbox: { width: 280, height: 160 },
                videoConstraints: { facingMode: "environment", width: { ideal: 1920 }, height: { ideal: 1080 } }
            };

            try {
                await html5QrCode.start({ facingMode: "environment" }, config, onScanSuccess);
                // Wait a tiny bit for the track to stabilize before setting zoom
                setTimeout(setupZoom, 500);
            } catch (err) { 
                console.error('Camera start failed', err);
                statusEl.innerText = "CAMERA ERROR";
                statusEl.className = "status-pill is-dup";
            }
        }

        async function setupZoom() {
            try {
                const track = await getActiveVideoTrack();
                if (!track) {
                    console.log('No active track found for zoom/torch');
                    return;
                }
                const caps = track.getCapabilities ? track.getCapabilities() : {};
                // Zoom
                if (caps && typeof caps.zoom !== 'undefined') {
                    const min = caps.zoom.min ?? 1;
                    const max = caps.zoom.max ?? 1;
                    const step = caps.zoom.step ?? 0.1;
                    zoomContainer.style.display = "block";
                    zoomDial.min = min;
                    zoomDial.max = max;
                    zoomDial.step = step;
                    // Default to 2x or mid value if available
                    const defaultZoom = Math.min(2.0, max);
                    zoomDial.value = defaultZoom;
                    applyZoom(zoomDial.value);
                    zoomDial.addEventListener('input', (e) => applyZoom(e.target.value));
                } else {
                    console.log('Zoom capability not present');
                }
                // Torch
                if (caps && caps.torch) {
                    torchBtn.style.display = "block";
                } else {
                    // Some browsers expose torch capability differently; still show if track supports applyConstraints torch
                    try {
                        // quick test applyConstraints with same value to see if it throws
                        await track.applyConstraints({ advanced: [{ torch: isTorchOn }] }).catch(() => {});
                        torchBtn.style.display = "block";
                    } catch (e) {
                        console.log('Torch not supported', e);
                    }
                }
            } catch (e) {
                console.log("Zoom setup skipped or failed", e);
            }
        }

        async function applyZoom(val) {
            try {
                const track = await getActiveVideoTrack();
                if (!track) return;
                const numeric = parseFloat(val);
                zoomValue.innerText = `${numeric.toFixed(1)}x`;
                // Some devices expect zoom as number, others as 'zoom'
                await track.applyConstraints({ advanced: [{ zoom: numeric }] });
            } catch (e) {
                console.error("Zoom failed", e);
            }
        }

        function onScanSuccess(decodedText) {
            const cleanCode = decodedText.trim();

            // Keep scanning continuous even if isLock is true.
            // isLock only prevents pushes; UI still updates for each new code.
            if (cache.has(cleanCode)) {
                statusEl.innerText = `DUPLICATE: ${cleanCode}`;
                statusEl.className = "status-pill is-dup";
                // still show the serial so operator sees it
                serialTxt.innerText = cleanCode;
                manualForm.style.display = "block";
                return; 
            }

            if (cleanCode !== serialTxt.innerText) {
                statusEl.innerText = "CODE CAPTURED";
                statusEl.className = "status-pill ready";
                serialTxt.innerText = cleanCode;
                nameInput.value = ""; 
                manualForm.style.display = "block";
                if (navigator.vibrate) navigator.vibrate([40, 40]);

                // Only auto-push if not locked
                if (contSwitch.checked && !isLock) {
                    autoPush(cleanCode);
                }
            }
        }

        async function autoPush(serial) {
            // keep isLock behavior as before to prevent concurrent pushes
            isLock = true;
            statusEl.innerText = "AUTO-SENDING...";
            await sendData("", serial);
            // release lock after a short delay to allow continuous scanning to continue
            setTimeout(() => { isLock = false; }, 1200); 
        }

        async function manualPush() {
            // keep isLock behavior as before
            isLock = true;
            statusEl.innerText = "SENDING...";
            await sendData(nameInput.value, serialTxt.innerText);
            manualForm.style.display = "none";
            serialTxt.innerText = "---";
            isLock = false;
        }

        async function sendData(name, serial) {
            const query = `?action=push&name=${encodeURIComponent(name)}&serial=${encodeURIComponent(serial)}`;
            try {
                const res = await fetch(scriptURL + query);
                const result = await res.json();
                if (result.status === "success") {
                    cache.add(serial);
                    statusEl.innerText = "SUCCESSFULLY PUSHED";
                    statusEl.className = "status-pill ready";
                } else {
                    console.warn('Push returned non-success', result);
                    statusEl.innerText = "PUSH FAILED";
                    statusEl.className = "status-pill is-dup";
                }
            } catch (e) { 
                console.error('Connection failed', e);
                statusEl.innerText = "CONNECTION FAILED";
                statusEl.className = "status-pill is-dup";
            }
        }

        async function toggleTorch() {
            try {
                isTorchOn = !isTorchOn;
                const track = await getActiveVideoTrack();
                if (!track) return;
                await track.applyConstraints({ advanced: [{ torch: isTorchOn }] });
            } catch (e) {
                console.log('Torch toggle failed', e);
            }
        }

        async function refreshAll() {
            // Graceful refresh: re-fetch cache and restart scanner without full page reload
            statusEl.innerText = "REFRESHING...";
            statusEl.className = "status-pill syncing";
            try {
                const res = await fetch(`${scriptURL}?action=fetch`);
                const data = await res.json();
                cache.clear();
                if (data.serials) data.serials.forEach(s => cache.add(String(s).trim()));
                statusEl.innerText = `${cache.size} ITEMS LOADED`;
                statusEl.className = "status-pill ready";
            } catch (e) {
                console.warn('Refresh fetch failed', e);
                statusEl.innerText = "OFFLINE MODE";
                statusEl.className = "status-pill syncing";
            }
            // restart scanner to ensure track/capabilities re-evaluated
            try {
                await html5QrCode.stop();
            } catch (e) { /* ignore */ }
            try {
                const config = { fps: 30, qrbox: { width: 280, height: 160 }, videoConstraints: { facingMode: "environment" } };
                await html5QrCode.start({ facingMode: "environment" }, config, onScanSuccess);
                setTimeout(setupZoom, 500);
            } catch (e) {
                console.error('Restart scanner failed', e);
            }
        }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>