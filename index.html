<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dynamic Pro Scanner</title>
  <script src="https://unpkg.com/html5-qrcode"></script>
  <style>
    :root{
      --primary:#2563eb;
      --bg:#0f172a;
      --card:#0f172a;
      --muted:#94a3b8;
      --accent:#60a5fa;
      --border:#334155;
      --success:#16a34a;
      --danger:#dc2626;
      --surface:#1e293b;
      --control:#475569;
      --radius:12px;
    }

    html,body{height:100%}
    body{
      margin:0;
      min-height:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
      padding:14px;
      background:linear-gradient(180deg,var(--bg),#071029 120%);
      color:#fff;
      font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Reader wrapper */
    #reader-wrapper{
      width:100%;
      max-width:540px;
      border-radius:var(--radius);
      overflow:hidden;
      background:#000;
      border:2px solid var(--border);
      box-shadow:0 6px 18px rgba(2,6,23,0.6);
      position:relative;
      aspect-ratio:16/9;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* Ensure video covers area */
    #reader video{
      width:100% !important;
      height:100% !important;
      object-fit:cover !important;
      transform: none !important;
      filter:contrast(1.6) brightness(1.05) grayscale(0.15);
    }

    /* Card */
    .card{
      width:100%;
      max-width:540px;
      background:var(--surface);
      border-radius:var(--radius);
      padding:14px;
      box-sizing:border-box;
      border:1px solid var(--border);
      box-shadow:0 4px 12px rgba(2,6,23,0.45);
    }

    /* Status pill */
    .status-pill{
      display:inline-block;
      width:100%;
      text-align:center;
      padding:10px 12px;
      border-radius:10px;
      font-weight:800;
      font-size:0.85rem;
      text-transform:uppercase;
      letter-spacing:0.6px;
      box-sizing:border-box;
      margin-bottom:12px;
    }
    .syncing{background:#0b1220;color:var(--muted);border:1px solid var(--border)}
    .ready{background:var(--success);color:#fff}
    .is-dup{background:var(--danger);color:#fff}
    .pending{background:#334155;color:var(--muted)}

    /* Zoom row */
    .zoom-row{
      display:flex;
      flex-direction:column;
      gap:8px;
      background:var(--card);
      padding:10px;
      border-radius:8px;
      border:1px solid var(--border);
      margin-bottom:12px;
    }
    .zoom-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:0.78rem;
      color:var(--muted);
      font-weight:700;
    }
    input[type="range"]{
      width:100%;
      height:10px;
      background:transparent;
      -webkit-appearance:none;
      appearance:none;
      outline:none;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height:8px;
      background:var(--border);
      border-radius:6px;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:18px;
      height:18px;
      border-radius:50%;
      background:var(--primary);
      margin-top:-5px;
      box-shadow:0 2px 6px rgba(37,99,235,0.35);
    }

    /* Form controls */
    .controls-row{display:flex;gap:10px;align-items:center;margin-bottom:12px}
    .controls-row input[type="checkbox"]{width:18px;height:18px}
    label[for="cont-scan"]{font-size:0.95rem;color:var(--muted);font-weight:600}

    /* Always-visible serial entry */
    .serial-row{
      display:flex;
      gap:8px;
      align-items:center;
      margin-bottom:10px;
    }
    #serial-input{
      flex:1;
      padding:12px;
      border-radius:8px;
      border:1px solid var(--border);
      background:#071226;
      color:#fff;
      font-size:15px;
      box-sizing:border-box;
    }
    #serial-label{font-size:0.85rem;color:var(--muted);font-weight:700;margin-right:6px}

    #manual-form{display:block;border-top:1px solid #475569;padding-top:12px;margin-top:8px}
    #display-serial{display:none;font-size:1.25rem;font-weight:800;color:var(--accent);margin-bottom:8px}
    input[type="text"]{
      width:100%;
      padding:12px;
      border-radius:8px;
      border:1px solid var(--border);
      background:#071226;
      color:#fff;
      font-size:15px;
      box-sizing:border-box;
      margin-bottom:8px;
    }

    /* Buttons */
    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      padding:12px 14px;
      border-radius:10px;
      border:none;
      cursor:pointer;
      font-weight:800;
      font-size:0.95rem;
    }
    .btn-primary{background:var(--primary);color:#fff}
    .btn-muted{background:var(--control);color:#fff}
    .btn-disabled{background:#2b3946;color:#94a3b8;cursor:not-allowed}
    .bottom-btns{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      margin-top:8px;
    }
    #torch-btn{display:none}

    /* Small helper text */
    .helper { font-size:0.85rem; color:var(--muted); margin-top:6px; }

    @media (max-width:420px){
      #reader-wrapper{aspect-ratio:4/3}
      .card{padding:12px}
      .status-pill{padding:8px;font-size:0.8rem}
      .btn{padding:10px;font-size:0.9rem}
    }
  </style>
</head>
<body>

  <div id="reader-wrapper">
    <div id="reader" aria-label="Camera preview"></div>
  </div>

  <div class="card" role="region" aria-label="Scanner controls">
    <div id="status" class="status-pill syncing">FETCHING DATABASE...</div>

    <div id="zoom-container" class="zoom-row" style="display:none;">
      <div class="zoom-header">
        <span>ZOOM MAGNIFICATION</span>
        <span id="zoom-value">1.0x</span>
      </div>
      <input type="range" id="zoom-dial" min="1" max="5" step="0.1" value="1" aria-label="Zoom dial">
    </div>

    <div class="controls-row">
      <input type="checkbox" id="cont-scan" aria-label="Auto push to sheet">
      <label for="cont-scan">Auto-Push to Sheet</label>
    </div>

    <!-- Always-visible serial entry -->
    <div class="serial-row" aria-hidden="false">
      <div id="serial-label">Serial</div>
      <input id="serial-input" type="text" placeholder="Scan or type serial here" aria-label="Serial entry">
    </div>

    <!-- Manual form (name + push/cancel) -->
    <div id="manual-form">
      <input id="item-name" type="text" placeholder="Item Name (Optional)" aria-label="Item name">
      <div style="display:flex;gap:10px;">
        <button id="push-btn" class="btn btn-primary" onclick="manualPush()">PUSH DATA</button>
        <button id="cancel-btn" class="btn btn-muted" onclick="clearSerial()">CANCEL</button>
      </div>
      <div id="helper-text" class="helper"></div>
    </div>

    <div class="bottom-btns" style="margin-top:12px">
      <button id="torch-btn" class="btn btn-muted" onclick="toggleTorch()">ðŸ”¦ LIGHT</button>
      <button class="btn btn-muted" onclick="refreshAll()">ðŸ”„ REFRESH</button>
    </div>
  </div>

  <script>
    // === CONFIG ===
    const scriptURL = "https://script.google.com/macros/s/AKfycbyHSRlm4NTMABkzxi_uWudSDeo9Z7cSOm9vlKYGjvKe9d1yX2jyEKTQlfbJfWWYQOng/exec";

    // === STATE ===
    const cache = new Set();        // normalized serials known to exist
    const pending = new Set();      // serials currently being pushed (optimistic)
    let lastRow = 1;                // last known row index on server (1 = header)
    let isLock = false;             // prevents concurrent push operations
    let html5QrCode;
    let isTorchOn = false;

    // === DOM ===
    const statusEl = document.getElementById('status');
    const contSwitch = document.getElementById('cont-scan');
    const manualForm = document.getElementById('manual-form');
    const serialInput = document.getElementById('serial-input');
    const nameInput = document.getElementById('item-name');
    const torchBtn = document.getElementById('torch-btn');
    const zoomDial = document.getElementById('zoom-dial');
    const zoomValue = document.getElementById('zoom-value');
    const zoomContainer = document.getElementById('zoom-container');
    const pushBtn = document.getElementById('push-btn');
    const cancelBtn = document.getElementById('cancel-btn');
    const helperText = document.getElementById('helper-text');

    // Debounce / scan suppression
    let lastScanAt = 0;
    let lastScanCode = null;
    const SCAN_DEBOUNCE_MS = 900;

    // === UTILITIES ===
    function normalizeCode(raw) {
      if (raw === null || raw === undefined) return "";
      let s = String(raw).trim();
      s = s.replace(/[\u200B-\u200D\uFEFF]/g, "");
      s = s.replace(/[\x00-\x1F\x7F]/g, "");
      s = s.replace(/\s+/g, "");
      return s.toUpperCase();
    }

    function setStatus(text, cls) {
      statusEl.innerText = text;
      statusEl.className = "status-pill " + cls;
    }

    function updatePushButtonStateFromInput() {
      const norm = normalizeCode(serialInput.value);
      if (!norm || norm === '---') {
        pushBtn.className = 'btn btn-primary btn-disabled';
        pushBtn.disabled = true;
        helperText.innerText = '';
        return;
      }
      if (pending.has(norm)) {
        pushBtn.className = 'btn btn-disabled';
        pushBtn.disabled = true;
        helperText.innerText = 'Push pending...';
        return;
      }
      if (cache.has(norm)) {
        pushBtn.className = 'btn btn-disabled';
        pushBtn.disabled = true;
        helperText.innerText = 'Duplicate detected â€” push disabled';
        return;
      }
      pushBtn.className = 'btn btn-primary';
      pushBtn.disabled = false;
      helperText.innerText = '';
    }

    // Reliable track getter (tries library then video element)
    async function getActiveVideoTrack(retries = 6, delayMs = 300) {
      try {
        if (html5QrCode && typeof html5QrCode.getRunningTrack === 'function') {
          const t = html5QrCode.getRunningTrack();
          if (t) return t;
        }
      } catch (e) { console.log('getRunningTrack not available', e); }

      for (let i = 0; i < retries; i++) {
        try {
          const video = document.querySelector('#reader video');
          if (video && video.srcObject) {
            const tracks = video.srcObject.getVideoTracks();
            if (tracks && tracks.length) return tracks[0];
          }
        } catch (e) { console.log('video track read attempt failed', e); }
        await new Promise(r => setTimeout(r, delayMs));
      }
      return null;
    }

    // === INITIALIZATION ===
    async function init() {
      html5QrCode = new Html5Qrcode("reader");

      // Initial fetch: get all known serials and lastRow
      try {
        const res = await fetch(`${scriptURL}?action=fetch`);
        const data = await res.json();
        if (data && Array.isArray(data.serials)) {
          data.serials.forEach(obj => {
            if (obj && obj.serial) cache.add(normalizeCode(obj.serial));
          });
        }
        lastRow = (data && Number.isFinite(data.lastRow)) ? data.lastRow : lastRow;
        setStatus(`${cache.size} ITEMS LOADED`, 'ready');
      } catch (e) {
        console.warn('Initial fetch failed, offline mode', e);
        setStatus('OFFLINE MODE', 'syncing');
      }

      // Start camera
      const config = {
        fps: 30,
        qrbox: { width: 280, height: 160 },
        videoConstraints: { facingMode: "environment", width: { ideal: 1920 }, height: { ideal: 1080 } }
      };

      try {
        await html5QrCode.start({ facingMode: "environment" }, config, onScanSuccess);
        setTimeout(setupZoom, 500);
      } catch (err) {
        console.error('Camera start failed', err);
        setStatus('CAMERA ERROR', 'is-dup');
      }

      // Wire input events
      serialInput.addEventListener('input', () => {
        updatePushButtonStateFromInput();
      });
      nameInput.addEventListener('input', () => updatePushButtonStateFromInput());
      // initialize button state
      updatePushButtonStateFromInput();
    }

    // === ZOOM / TORCH ===
    async function setupZoom() {
      try {
        const track = await getActiveVideoTrack();
        if (!track) return;
        const caps = track.getCapabilities ? track.getCapabilities() : {};
        if (caps && typeof caps.zoom !== 'undefined') {
          const min = caps.zoom.min ?? 1;
          const max = caps.zoom.max ?? 1;
          const step = caps.zoom.step ?? 0.1;
          zoomContainer.style.display = "block";
          zoomDial.min = min;
          zoomDial.max = max;
          zoomDial.step = step;
          const defaultZoom = Math.min(2.0, max);
          zoomDial.value = defaultZoom;
          applyZoom(zoomDial.value);
          zoomDial.addEventListener('input', (e) => applyZoom(e.target.value));
        }
        if (caps && caps.torch) {
          torchBtn.style.display = "block";
        } else {
          try {
            await track.applyConstraints({ advanced: [{ torch: isTorchOn }] }).catch(() => {});
            torchBtn.style.display = "block";
          } catch (e) { console.log('Torch not supported', e); }
        }
      } catch (e) { console.log("Zoom setup skipped or failed", e); }
    }

    async function applyZoom(val) {
      try {
        const track = await getActiveVideoTrack();
        if (!track) return;
        const numeric = parseFloat(val);
        zoomValue.innerText = `${numeric.toFixed(1)}x`;
        await track.applyConstraints({ advanced: [{ zoom: numeric }] });
      } catch (e) { console.error("Zoom failed", e); }
    }

    // === SCAN HANDLING ===
    function onScanSuccess(decodedText) {
      const now = Date.now();
      const raw = String(decodedText || "");
      const norm = normalizeCode(raw);

      // Debounce repeated scans of same code
      if (norm && norm === lastScanCode && (now - lastScanAt) < SCAN_DEBOUNCE_MS) {
        return;
      }
      lastScanAt = now;
      lastScanCode = norm;

      if (!norm) return;

      // Put scanned content into always-visible serial input for editing
      serialInput.value = norm;
      updatePushButtonStateFromInput();
      // show manual form (already visible) and focus serial input so user can edit
      serialInput.focus();

      // Duplicate check (local)
      if (cache.has(norm)) {
        setStatus(`DUPLICATE: ${norm}`, 'is-dup');
        updatePushButtonStateFromInput();
        if (navigator.vibrate) navigator.vibrate([30]);
        return;
      }

      setStatus('CODE CAPTURED', 'ready');
      updatePushButtonStateFromInput();
      if (navigator.vibrate) navigator.vibrate([40, 40]);

      // Auto-push behavior: optimistic add then send (keeps previous behavior)
      if (contSwitch.checked && !isLock) {
        startPush(norm, "");
      }
    }

    // === PUSH FLOW (optimistic + server sync) ===
    async function startPush(serialRaw, name) {
      const serial = normalizeCode(serialRaw);
      if (!serial) return;

      // If already known or pending, skip
      if (cache.has(serial) || pending.has(serial)) {
        updatePushButtonStateFromInput();
        return;
      }

      // Optimistic: mark pending and add to cache immediately
      pending.add(serial);
      cache.add(serial);
      updatePushButtonStateFromInput();
      setStatus('PENDING SEND...', 'pending');

      isLock = true;

      try {
        const result = await sendData(name, serial);
        // result is parsed JSON or thrown on network error
        if (result && result.status === 'success') {
          // server accepted; update lastRow if provided
          if (Number.isFinite(result.row)) lastRow = Math.max(lastRow, result.row);
          pending.delete(serial);
          setStatus('SUCCESSFULLY PUSHED', 'ready');
        } else if (result && result.status === 'duplicate') {
          // server says duplicate: ensure cache contains it and show duplicate message
          pending.delete(serial);
          cache.add(serial);
          if (Number.isFinite(result.row)) lastRow = Math.max(lastRow, result.row);
          setStatus(`DUPLICATE (row ${result.row || '?'})`, 'is-dup');
        } else {
          // non-success response
          pending.delete(serial);
          cache.delete(serial); // rollback optimistic add
          setStatus('PUSH FAILED', 'is-dup');
        }
      } catch (e) {
        // network or unexpected error: rollback optimistic add
        pending.delete(serial);
        cache.delete(serial);
        setStatus('CONNECTION FAILED', 'is-dup');
      } finally {
        // release lock after short delay to allow continuous scanning
        setTimeout(() => { isLock = false; }, 800);
        updatePushButtonStateFromInput();
      }
    }

    async function manualPush() {
      const raw = serialInput.value || "";
      const serial = normalizeCode(raw);
      if (!serial) return;
      if (cache.has(serial) && !pending.has(serial)) {
        updatePushButtonStateFromInput();
        return;
      }
      await startPush(serial, nameInput.value || "");
      // If push succeeded or at least recorded locally, clear input and name
      if (!pending.has(serial) && cache.has(serial)) {
        serialInput.value = '';
        nameInput.value = '';
        updatePushButtonStateFromInput();
      }
    }

    // sendData: performs the fetch to the Apps Script and returns parsed JSON
    async function sendData(name, serial) {
      const query = `?action=push&name=${encodeURIComponent(name)}&serial=${encodeURIComponent(serial)}`;
      const res = await fetch(scriptURL + query);
      const json = await res.json();
      return json;
    }

    // === REFRESH / INCREMENTAL SYNC ===
    async function refreshAll() {
      setStatus('REFRESHING...', 'syncing');
      try {
        // Use sinceRow to fetch only new rows after lastRow
        const since = (Number.isFinite(lastRow) && lastRow >= 1) ? lastRow + 1 : 2;
        const res = await fetch(`${scriptURL}?action=fetch&sinceRow=${since}`);
        const data = await res.json();
        if (data && Array.isArray(data.serials) && data.serials.length) {
          data.serials.forEach(obj => {
            if (obj && obj.serial) cache.add(normalizeCode(obj.serial));
            if (obj && Number.isFinite(obj.row)) lastRow = Math.max(lastRow, obj.row);
          });
        }
        // If server returned lastRow, trust it
        if (data && Number.isFinite(data.lastRow)) lastRow = Math.max(lastRow, data.lastRow);
        setStatus(`${cache.size} ITEMS LOADED`, 'ready');
      } catch (e) {
        console.warn('Refresh failed', e);
        setStatus('OFFLINE MODE', 'syncing');
      }

      // restart scanner to re-evaluate track capabilities
      try { await html5QrCode.stop(); } catch (e) {}
      try {
        const config = { fps: 30, qrbox: { width: 280, height: 160 }, videoConstraints: { facingMode: "environment" } };
        await html5QrCode.start({ facingMode: "environment" }, config, onScanSuccess);
        setTimeout(setupZoom, 500);
      } catch (e) { console.error('Restart scanner failed', e); }
    }

    // Cancel / clear current serial in manual form
    function clearSerial() {
      serialInput.value = '';
      nameInput.value = '';
      helperText.innerText = '';
      updatePushButtonStateFromInput();
    }

    // Torch toggle
    async function toggleTorch() {
      try {
        isTorchOn = !isTorchOn;
        const track = await getActiveVideoTrack();
        if (!track) return;
        await track.applyConstraints({ advanced: [{ torch: isTorchOn }] });
      } catch (e) { console.log('Torch toggle failed', e); }
    }

    // Start
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
