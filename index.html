<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dynamic Pro Scanner</title>
  <script src="https://unpkg.com/html5-qrcode"></script>
  <style>
    :root{
      --primary:#2563eb;
      --bg:#0f172a;
      --card:#0f172a;
      --muted:#94a3b8;
      --accent:#60a5fa;
      --border:#334155;
      --success:#16a34a;
      --danger:#dc2626;
      --surface:#1e293b;
      --control:#475569;
      --radius:12px;
    }

    html,body{height:100%}
    body{
      margin:0;
      min-height:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
      padding:14px;
      background:linear-gradient(180deg,var(--bg),#071029 120%);
      color:#fff;
      font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Reader wrapper */
    #reader-wrapper{
      width:100%;
      max-width:540px;
      border-radius:var(--radius);
      overflow:hidden;
      background:#000;
      border:2px solid var(--border);
      box-shadow:0 6px 18px rgba(2,6,23,0.6);
      position:relative;
      aspect-ratio:16/9;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* Ensure video covers area */
    #reader video{
      width:100% !important;
      height:100% !important;
      object-fit:cover !important;
      transform: none !important;
      filter:contrast(1.6) brightness(1.05) grayscale(0.15);
    }

    /* Card */
    .card{
      width:100%;
      max-width:540px;
      background:var(--surface);
      border-radius:var(--radius);
      padding:14px;
      box-sizing:border-box;
      border:1px solid var(--border);
      box-shadow:0 4px 12px rgba(2,6,23,0.45);
    }

    /* Status pill */
    .status-pill{
      display:inline-block;
      width:100%;
      text-align:center;
      padding:10px 12px;
      border-radius:10px;
      font-weight:800;
      font-size:0.85rem;
      text-transform:uppercase;
      letter-spacing:0.6px;
      box-sizing:border-box;
      margin-bottom:12px;
    }
    .syncing{background:#0b1220;color:var(--muted);border:1px solid var(--border)}
    .ready{background:var(--success);color:#fff}
    .is-dup{background:var(--danger);color:#fff}
    .pending{background:#334155;color:var(--muted)}

    /* Zoom row */
    .zoom-row{
      display:flex;
      flex-direction:column;
      gap:8px;
      background:var(--card);
      padding:10px;
      border-radius:8px;
      border:1px solid var(--border);
      margin-bottom:12px;
    }
    .zoom-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:0.78rem;
      color:var(--muted);
      font-weight:700;
    }
    input[type="range"]{
      width:100%;
      height:10px;
      background:transparent;
      -webkit-appearance:none;
      appearance:none;
      outline:none;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height:8px;
      background:var(--border);
      border-radius:6px;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:18px;
      height:18px;
      border-radius:50%;
      background:var(--primary);
      margin-top:-5px;
      box-shadow:0 2px 6px rgba(37,99,235,0.35);
    }

    /* Form controls */
    .controls-row{display:flex;gap:10px;align-items:center;margin-bottom:12px}
    .controls-row input[type="checkbox"]{width:18px;height:18px}
    label[for="cont-scan"]{font-size:0.95rem;color:var(--muted);font-weight:600}

    #manual-form{display:none;border-top:1px solid #475569;padding-top:12px;margin-top:8px}
    #display-serial{font-size:1.25rem;font-weight:800;color:var(--accent);margin-bottom:8px}
    input[type="text"]{
      width:100%;
      padding:12px;
      border-radius:8px;
      border:1px solid var(--border);
      background:#071226;
      color:#fff;
      font-size:15px;
      box-sizing:border-box;
      margin-bottom:8px;
    }

    /* Buttons */
    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      padding:12px 14px;
      border-radius:10px;
      border:none;
      cursor:pointer;
      font-weight:800;
      font-size:0.95rem;
    }
    .btn-primary{background:var(--primary);color:#fff}
    .btn-muted{background:var(--control);color:#fff}
    .btn-disabled{background:#2b3946;color:#94a3b8;cursor:not-allowed}
    .bottom-btns{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      margin-top:8px;
    }
    #torch-btn{display:none}

    /* Small helper text */
    .helper { font-size:0.85rem; color:var(--muted); margin-top:6px; }

    @media (max-width:420px){
      #reader-wrapper{aspect-ratio:4/3}
      .card{padding:12px}
      .status-pill{padding:8px;font-size:0.8rem}
      .btn{padding:10px;font-size:0.9rem}
    }
  </style>
</head>
<body>

  <div id="reader-wrapper">
    <div id="reader" aria-label="Camera preview"></div>
  </div>

  <div class="card" role="region" aria-label="Scanner controls">
    <div id="status" class="status-pill syncing">FETCHING DATABASE...</div>

    <div id="zoom-container" class="zoom-row" style="display:none;">
      <div class="zoom-header">
        <span>ZOOM MAGNIFICATION</span>
        <span id="zoom-value">1.0x</span>
      </div>
      <input type="range" id="zoom-dial" min="1" max="5" step="0.1" value="1" aria-label="Zoom dial">
    </div>

    <div class="controls-row">
      <input type="checkbox" id="cont-scan" aria-label="Auto push to sheet">
      <label for="cont-scan">Auto-Push to Sheet</label>
    </div>

    <div id="manual-form">
      <div id="display-serial">---</div>
      <input id="item-name" type="text" placeholder="Item Name (Optional)" aria-label="Item name">
      <div style="display:flex;gap:10px;">
        <button id="push-btn" class="btn btn-primary" onclick="manualPush()">PUSH DATA</button>
        <button id="cancel-btn" class="btn btn-muted" onclick="clearSerial()">CANCEL</button>
      </div>
      <div id="helper-text" class="helper"></div>
    </div>

    <div class="bottom-btns" style="margin-top:12px">
      <button id="torch-btn" class="btn btn-muted" onclick="toggleTorch()">ðŸ”¦ LIGHT</button>
      <button class="btn btn-muted" onclick="refreshAll()">ðŸ”„ REFRESH</button>
    </div>
  </div>

  <script>
    const scriptURL = "https://script.google.com/macros/s/AKfycbzNSy4eQ5Tm3ZR429ozDAp7MekYHzQu5qEmLAFgYpqtUaxHGAIjMcEG5a4R9vqrrhKn/exec";
    const cache = new Set();
    const pending = new Set(); // serials currently being pushed
    let isLock = false;
    let html5QrCode;
    let isTorchOn = false;

    const statusEl = document.getElementById('status');
    const contSwitch = document.getElementById('cont-scan');
    const manualForm = document.getElementById('manual-form');
    const serialTxt = document.getElementById('display-serial');
    const nameInput = document.getElementById('item-name');
    const torchBtn = document.getElementById('torch-btn');
    const zoomDial = document.getElementById('zoom-dial');
    const zoomValue = document.getElementById('zoom-value');
    const zoomContainer = document.getElementById('zoom-container');
    const pushBtn = document.getElementById('push-btn');
    const cancelBtn = document.getElementById('cancel-btn');
    const helperText = document.getElementById('helper-text');

    // Debounce / scan suppression
    let lastScanAt = 0;
    let lastScanCode = null;
    const SCAN_DEBOUNCE_MS = 900;

    // Normalize scanned codes to canonical form
    function normalizeCode(raw) {
      if (!raw && raw !== "") return "";
      // Trim, remove control/zero-width chars, collapse whitespace, uppercase
      let s = String(raw).trim();
      // remove zero-width and non-printable
      s = s.replace(/[\u200B-\u200D\uFEFF]/g, "");
      s = s.replace(/[\x00-\x1F\x7F]/g, "");
      // collapse internal whitespace
      s = s.replace(/\s+/g, "");
      return s.toUpperCase();
    }

    // Helper to update push button state based on current serial
    function updatePushButtonState(serial) {
      const norm = normalizeCode(serial);
      if (!norm || norm === '---') {
        pushBtn.className = 'btn btn-primary btn-disabled';
        pushBtn.disabled = true;
        helperText.innerText = '';
        return;
      }
      if (pending.has(norm)) {
        pushBtn.className = 'btn btn-disabled';
        pushBtn.disabled = true;
        helperText.innerText = 'Push pending...';
        return;
      }
      if (cache.has(norm)) {
        pushBtn.className = 'btn btn-disabled';
        pushBtn.disabled = true;
        helperText.innerText = 'Duplicate detected â€” push disabled';
        return;
      }
      // otherwise enable
      pushBtn.className = 'btn btn-primary';
      pushBtn.disabled = false;
      helperText.innerText = '';
    }

    // Helper to get active video track reliably
    async function getActiveVideoTrack(retries = 6, delayMs = 300) {
      try {
        if (html5QrCode && typeof html5QrCode.getRunningTrack === 'function') {
          const t = html5QrCode.getRunningTrack();
          if (t) return t;
        }
      } catch (e) { console.log('getRunningTrack not available', e); }

      for (let i = 0; i < retries; i++) {
        try {
          const video = document.querySelector('#reader video');
          if (video && video.srcObject) {
            const tracks = video.srcObject.getVideoTracks();
            if (tracks && tracks.length) return tracks[0];
          }
        } catch (e) { console.log('video track read attempt failed', e); }
        await new Promise(r => setTimeout(r, delayMs));
      }
      return null;
    }

    async function init() {
      html5QrCode = new Html5Qrcode("reader");

      // 1. Fetch Duplicates (initial)
      try {
        const res = await fetch(`${scriptURL}?action=fetch`);
        const data = await res.json();
        if (data.serials) data.serials.forEach(s => cache.add(String(s).trim().toUpperCase()));
        statusEl.innerText = `${cache.size} ITEMS LOADED`;
        statusEl.className = "status-pill ready";
      } catch (e) {
        console.warn('Fetch failed, offline mode', e);
        statusEl.innerText = "OFFLINE MODE";
        statusEl.className = "status-pill syncing";
      }

      // 2. Start Camera
      const config = {
        fps: 30,
        qrbox: { width: 280, height: 160 },
        videoConstraints: { facingMode: "environment", width: { ideal: 1920 }, height: { ideal: 1080 } }
      };

      try {
        await html5QrCode.start({ facingMode: "environment" }, config, onScanSuccess);
        setTimeout(setupZoom, 500);
      } catch (err) {
        console.error('Camera start failed', err);
        statusEl.innerText = "CAMERA ERROR";
        statusEl.className = "status-pill is-dup";
      }
    }

    async function setupZoom() {
      try {
        const track = await getActiveVideoTrack();
        if (!track) return;
        const caps = track.getCapabilities ? track.getCapabilities() : {};
        if (caps && typeof caps.zoom !== 'undefined') {
          const min = caps.zoom.min ?? 1;
          const max = caps.zoom.max ?? 1;
          const step = caps.zoom.step ?? 0.1;
          zoomContainer.style.display = "block";
          zoomDial.min = min;
          zoomDial.max = max;
          zoomDial.step = step;
          const defaultZoom = Math.min(2.0, max);
          zoomDial.value = defaultZoom;
          applyZoom(zoomDial.value);
          zoomDial.addEventListener('input', (e) => applyZoom(e.target.value));
        }
        if (caps && caps.torch) {
          torchBtn.style.display = "block";
        } else {
          try {
            await track.applyConstraints({ advanced: [{ torch: isTorchOn }] }).catch(() => {});
            torchBtn.style.display = "block";
          } catch (e) { console.log('Torch not supported', e); }
        }
      } catch (e) { console.log("Zoom setup skipped or failed", e); }
    }

    async function applyZoom(val) {
      try {
        const track = await getActiveVideoTrack();
        if (!track) return;
        const numeric = parseFloat(val);
        zoomValue.innerText = `${numeric.toFixed(1)}x`;
        await track.applyConstraints({ advanced: [{ zoom: numeric }] });
      } catch (e) { console.error("Zoom failed", e); }
    }

    // Debounced scan handler
    function onScanSuccess(decodedText) {
      const now = Date.now();
      const raw = String(decodedText || "");
      const norm = normalizeCode(raw);

      // Basic debounce: ignore same code scanned repeatedly within SCAN_DEBOUNCE_MS
      if (norm && norm === lastScanCode && (now - lastScanAt) < SCAN_DEBOUNCE_MS) {
        return;
      }
      lastScanAt = now;
      lastScanCode = norm;

      // Update UI and manual form
      if (!norm) return;
      serialTxt.innerText = norm;
      manualForm.style.display = "block";
      nameInput.value = "";

      // Duplicate check
      if (cache.has(norm)) {
        statusEl.innerText = `DUPLICATE: ${norm}`;
        statusEl.className = "status-pill is-dup";
        updatePushButtonState(norm);
        if (navigator.vibrate) navigator.vibrate([30]);
        return;
      }

      // Not in cache
      statusEl.innerText = "CODE CAPTURED";
      statusEl.className = "status-pill ready";
      updatePushButtonState(norm);
      if (navigator.vibrate) navigator.vibrate([40, 40]);

      // Auto-push behavior: optimistic add then send
      if (contSwitch.checked && !isLock) {
        // Start auto push with optimistic add
        startPush(norm, "");
      }
    }

    // Start push with optimistic add; returns a promise
    async function startPush(serialRaw, name) {
      const serial = normalizeCode(serialRaw);
      if (!serial) return;

      // If already in cache or pending, do nothing
      if (cache.has(serial) || pending.has(serial)) {
        updatePushButtonState(serial);
        return;
      }

      // Optimistic add: mark pending and add to cache immediately
      pending.add(serial);
      cache.add(serial);
      updatePushButtonState(serial);
      statusEl.innerText = "PENDING SEND...";
      statusEl.className = "status-pill pending";

      // Keep isLock behavior for concurrent pushes
      isLock = true;

      try {
        const success = await sendData(name, serial);
        if (success) {
          // push succeeded; pending cleared
          pending.delete(serial);
          statusEl.innerText = "SUCCESSFULLY PUSHED";
          statusEl.className = "status-pill ready";
        } else {
          // server returned non-success: rollback optimistic add
          pending.delete(serial);
          cache.delete(serial);
          statusEl.innerText = "PUSH FAILED";
          statusEl.className = "status-pill is-dup";
        }
      } catch (e) {
        // network or unexpected error: rollback optimistic add
        pending.delete(serial);
        cache.delete(serial);
        statusEl.innerText = "CONNECTION FAILED";
        statusEl.className = "status-pill is-dup";
      } finally {
        // release lock after short delay to allow continuous scanning
        setTimeout(() => { isLock = false; }, 800);
        updatePushButtonState(serial);
        // clear manual form serial if it matches
        if (serialTxt.innerText === serial) {
          // keep serial visible briefly; operator can clear manually
        }
      }
    }

    // Manual push triggered by button
    async function manualPush() {
      const raw = serialTxt.innerText || "";
      const serial = normalizeCode(raw);
      if (!serial) return;
      // If duplicate or pending, do nothing
      if (cache.has(serial) && !pending.has(serial)) {
        updatePushButtonState(serial);
        return;
      }
      // Use optimistic push flow
      await startPush(serial, nameInput.value || "");
      // hide manual form on success or failure? keep behavior: hide on success
      if (!pending.has(serial) && cache.has(serial)) {
        // assume success or at least recorded locally
        manualForm.style.display = "none";
        serialTxt.innerText = "---";
      }
    }

    // sendData returns true on success, false on non-success
    async function sendData(name, serial) {
      const query = `?action=push&name=${encodeURIComponent(name)}&serial=${encodeURIComponent(serial)}`;
      try {
        const res = await fetch(scriptURL + query);
        const result = await res.json();
        if (result && result.status === "success") {
          // server accepted; ensure cache contains serial (already added optimistically)
          return true;
        } else {
          console.warn('Push returned non-success', result);
          return false;
        }
      } catch (e) {
        console.error('Connection failed', e);
        throw e;
      }
    }

    // Cancel / clear current serial in manual form
    function clearSerial() {
      manualForm.style.display = "none";
      serialTxt.innerText = "---";
      nameInput.value = "";
      helperText.innerText = '';
    }

    async function toggleTorch() {
      try {
        isTorchOn = !isTorchOn;
        const track = await getActiveVideoTrack();
        if (!track) return;
        await track.applyConstraints({ advanced: [{ torch: isTorchOn }] });
      } catch (e) { console.log('Torch toggle failed', e); }
    }

    async function refreshAll() {
      statusEl.innerText = "REFRESHING...";
      statusEl.className = "status-pill syncing";
      try {
        const res = await fetch(`${scriptURL}?action=fetch`);
        const data = await res.json();
        cache.clear();
        pending.clear();
        if (data.serials) data.serials.forEach(s => cache.add(String(s).trim().toUpperCase()));
        statusEl.innerText = `${cache.size} ITEMS LOADED`;
        statusEl.className = "status-pill ready";
      } catch (e) {
        console.warn('Refresh fetch failed', e);
        statusEl.innerText = "OFFLINE MODE";
        statusEl.className = "status-pill syncing";
      }
      try { await html5QrCode.stop(); } catch (e) {}
      try {
        const config = { fps: 30, qrbox: { width: 280, height: 160 }, videoConstraints: { facingMode: "environment" } };
        await html5QrCode.start({ facingMode: "environment" }, config, onScanSuccess);
        setTimeout(setupZoom, 500);
      } catch (e) { console.error('Restart scanner failed', e); }
    }

    // Keep push button state in sync when user types a name or when serial changes
    nameInput.addEventListener('input', () => updatePushButtonState(serialTxt.innerText));
    // Initialize
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>